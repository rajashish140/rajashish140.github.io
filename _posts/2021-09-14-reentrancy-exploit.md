---
layout: post
title: Reentrancy Attack
---

One of the most devastating attacks you need to watch out for when developing smart contracts with Solidity are reentrancy attacks. They are devastating for two reasons: they can completely drain your smart contract of its ether, and they can sneak their way into your code if you’re not careful.
The hacker exploited a bug in the code of the DAO and stole more or less $50 million worth of ether

![ether-wallpaper](/images/reentrancy/ether.jpg)

<h2>Basic concepts</h2>

 In Ethereum there are two types of accounts:
 1. externally owned accounts controlled by humans and 
 2. contract accounts controlled by code.

 This is important because only contract accounts have associated code, and hence, can have a fallback function.

 ![types of account](/images/reentrancy/7bo.png)

 In Ethereum all the action is triggered by transactions or messages (calls) set off by externally owned accounts. Those transactions can be an ether transfer or the triggering of contract code. Remember, contracts can trigger other contracts’ code as well.

 Solidity supports three ways of transferring ether between wallets and smart contracts. These supported methods of transferring ether are 
 send(), transfer() and call.value().

 A contract can have at most one receive function, declared using receive() external payable { ... } (without the function keyword). This function cannot have arguments, cannot return anything and must have external visibility and payable state mutability. It is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via .send() or .transfer()). If no such function exists, but a payable fallback function exists, the fallback function will be called on a plain Ether transfer. If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through regular transactions and throws an exception.

 <h2>Attack</h2>
The fallback function abuse played a very important role in the DAO attack. Let’s see what a fallback function is and how it can be used for malicious purposes.

<h3>Fallback function</h3>
A contract can have one anonymous function, known as well as the fallback function. This function does not take any arguments and it is triggered in three cases :
1. If none of the functions of the call to the contract match any of the functions in the called contract
2. When the contract receives ether without extra data
3. If no data was supplied


<h2>Types of reentrancy attacks</h2>

1. Single function reentrancy attack

This type of attack is the simplest and easiest to prevent. It occurs when the vulnerable function is the same function the attacker is trying to recursively call.

![single reentrancy](/images/reentrancy/single.jpg)
    1.The attacker creates a contract which he executes the attack from. This contract has two functions. One to withdraw ETH from the DAO, the second that is called when ETH is received (standard part of any Solidity contract)

    2.The contract calls the withdraw function and the first line of the withdraw function is to send the ETH to the person who requested the withdrawl

    3.Since the requester is the contract and can call a function when it receives ETH, it then in turn calls the withdraw function on the DAO contract again!

    4.He keeps repeating this until his balance is updated at the end, but only for 1 withdrawal, not the amount of ETH he actually withdrew!

2. Cross-function reentrancy attack 

These attacks are harder to detect. A cross-function reentrancy attack is possible when a vulnerable function shares state with another function that has a desirable effect for the attacker.



These two registry keys are used as part of the encryption process.

LockBit is using the Input/Output Completion Ports (IOCPs).

IOCPs are a model for creating a queue to efficient threads to process multiple asynchronous I/O requests. They allow processes to handle many concurrent asynchronous I/O more quickly and efficiently without having to create new threads each time they get an I/O request.

![comparsion of speed](/images/lockbit/lockbit-encryption-comparison-table.jpg)

<h2>Underground forums </h2>

<h3>Trust</h3>

 LockBit has joined the underground darkweb forum with a clear determination to do business; the authors have put a down a deposit in excess of 10.5 BTC. Putting a deposit in escrow is a way to demonstrate that the seller is invested financially and not out to scam potential partners. 

 ![trust on darkweb](/images/lockbit/LockBit-deposit.png)
