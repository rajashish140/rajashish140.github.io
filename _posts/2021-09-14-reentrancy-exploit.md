---
layout: post
title: Reentrancy Attack
---

One of the most devastating attacks you need to watch out for when developing smart contracts with Solidity are reentrancy attacks. They are devastating for two reasons: they can completely drain your smart contract of its ether, and they can sneak their way into your code if you’re not careful.
The hacker exploited a bug in the code of the DAO and stole more or less $50 million worth of ether

![ether-wallpaper](/images/images/reentrancy/ether.jpg)

<h2>Basic concepts</h2>

 In Ethereum there are two types of accounts:
(1) externally owned accounts controlled by humans and 
 (2) contract accounts controlled by code.
 This is important because only contract accounts have associated code, and hence, can have a fallback function.

 ![types of account](/images/reentrancy/7bo.png)

 In Ethereum all the action is triggered by transactions or messages (calls) set off by externally owned accounts. Those transactions can be an ether transfer or the triggering of contract code. Remember, contracts can trigger other contracts’ code as well.

 Solidity supports three ways of transferring ether between wallets and smart contracts. These supported methods of transferring ether are 
 send(), transfer() and call.value().

 A contract can have at most one receive function, declared using receive() external payable { ... } (without the function keyword). This function cannot have arguments, cannot return anything and must have external visibility and payable state mutability. It is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via .send() or .transfer()). If no such function exists, but a payable fallback function exists, the fallback function will be called on a plain Ether transfer. If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through regular transactions and throws an exception.

 <h2>Attack</h2>
The fallback function abuse played a very important role in the DAO attack. Let’s see what a fallback function is and how it can be used for malicious purposes.

<h3>Fallback function</h3>
A contract can have one anonymous function, known as well as the fallback function. This function does not take any arguments and it is triggered in three cases :
1. If none of the functions of the call to the contract match any of the functions in the called contract
2. When the contract receives ether without extra data
3. If no data was supplied


<h2>Encrytion </h2>
HKEY_CURRENT_USER\Software\BDCDC5DF1C334E\Public
HKEY_CURRENT_USER\Software\BDCDC5DF1C334E\Private

![generating public and private keys and registry](/images/lockbit/generating public and privatate kes and registr.png)

These two registry keys are used as part of the encryption process.

LockBit is using the Input/Output Completion Ports (IOCPs).

IOCPs are a model for creating a queue to efficient threads to process multiple asynchronous I/O requests. They allow processes to handle many concurrent asynchronous I/O more quickly and efficiently without having to create new threads each time they get an I/O request.

![comparsion of speed](/images/lockbit/lockbit-encryption-comparison-table.jpg)

<h2>Underground forums </h2>

<h3>Trust</h3>

 LockBit has joined the underground darkweb forum with a clear determination to do business; the authors have put a down a deposit in excess of 10.5 BTC. Putting a deposit in escrow is a way to demonstrate that the seller is invested financially and not out to scam potential partners. 

 ![trust on darkweb](/images/lockbit/LockBit-deposit.png)
